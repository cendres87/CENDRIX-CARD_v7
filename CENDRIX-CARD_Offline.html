<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='90' height='70' x='5' y='15' rx='10' fill='%234f46e5' /><circle cx='30' cy='40' r='15' fill='%23e2e8f0' /><rect x='55' y='30' width='35' height='8' rx='2' fill='%23e2e8f0' /><rect x='55' y='45' width='25' height='6' rx='2' fill='%23a0aec0' /><rect x='55' y='58' width='25' height='6' rx='2' fill='%23a0aec0' /></svg>">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CENDRIX-CARD (Offline)</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- JSZip Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  
  <!-- XLSX (SheetJS) Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  
  <!-- React Libraries -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel Standalone for JSX compilation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-slate-900">
  <div id="root"></div>

  <script type="text/babel">
    // All React components and application logic will be placed here.
    // Note: All imports are removed as components will be in the same scope.
    
    // --- From types.ts ---
    // Interfaces are illustrative in JS but help structure the code.
    
    // --- From components/Icon.tsx ---
    const Icon = ({ name, className = 'w-5 h-5' }) => {
      const icons = {
        generate: (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.667 0l3.181-3.183m-4.991 0l-3.182-3.182a8.25 8.25 0 00-11.667 0l-3.181 3.182" />
          </svg>
        ),
        download: (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
          </svg>
        ),
        loading: (
          <svg className={`${className} animate-spin`} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
        ),
        placeholder: (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-16 h-16 text-slate-600">
            <path strokeLinecap="round" strokeLinejoin="round" d="M9 12h3.75M9 15h3.75M9 18h3.75m3 .75H18a2.25 2.25 0 002.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 00-1.123-.08m-5.801 0c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75c0-.231-.035-.454-.1-.664M6.75 7.5h1.5v-1.5h-1.5v1.5zm0 3h1.5v-1.5h-1.5v1.5zm0 3h1.5v-1.5h-1.5v1.5z" />
          </svg>
        ),
        save: (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
          </svg>
        ),
        upload: (
           <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
             <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
           </svg>
        ),
      };
      return icons[name] || null;
    };

    // --- From components/ErrorBubble.tsx ---
    const ErrorBubble = ({ error }) => {
      if (!error) return null;
      return (
        <div className="group absolute top-1/2 -right-3 -translate-y-1/2 z-10">
          <div className="w-6 h-6 bg-red-500 rounded-full flex items-center justify-center cursor-pointer shadow-lg animate-pulse">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" className="w-4 h-4 text-white">
              <path strokeLinecap="round" strokeLinejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" />
            </svg>
          </div>
          <div className="absolute bottom-full right-0 mb-2 w-64 p-3 bg-slate-800 border border-slate-600 rounded-lg shadow-xl opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-20">
            <p className="font-bold text-red-400 text-sm">{error.message}</p>
            <p className="text-xs text-slate-400 mt-1">{error.suggestion}</p>
            <div className="absolute top-full right-3 border-8 border-transparent border-t-slate-600"></div>
          </div>
        </div>
      );
    };

    // --- From components/Header.tsx ---
    const Header = () => {
      return (
        <header className="text-center mb-8">
          <h1 className="text-4xl font-extrabold text-white sm:text-5xl md:text-6xl tracking-tight">
            CENDRIX-CARD
          </h1>
          <p className="mt-4 max-w-2xl mx-auto text-lg text-slate-400">
            Crea credenciales visuales al instante a partir de una plantilla de imagen y un archivo de datos.
          </p>
        </header>
      );
    };
    
    // --- From components/Instructions.tsx ---
    const Instructions = () => {
      return (
        <div className="max-w-4xl mx-auto bg-slate-800/50 border border-slate-700 rounded-lg p-6">
          <h2 className="text-xl font-bold text-white mb-3">¿Cómo funciona?</h2>
          <ol className="list-decimal list-inside space-y-2 text-slate-300">
            <li>
              <strong>Carga una Plantilla:</strong> Sube una imagen (JPG o PNG) que servirá como fondo.
            </li>
             <li>
              <strong>Sube tu Archivo de Datos:</strong> Haz clic para seleccionar un archivo de Excel (.xlsx, .xls). La primera fila de la hoja debe contener los encabezados (ej., <code>id,nombre,puesto</code>).
            </li>
            <li>
              <strong>Carga las Fotos:</strong> Selecciona todos los archivos de imagen. **El nombre de cada archivo (sin la extensión) debe coincidir con un valor de la columna que vincules en los 'Campos de Imagen'.**
            </li>
            <li>
              <strong>Define los Campos:</strong> Añade campos de texto y de imagen. Para texto, usa marcadores <code>{'{{columna}}'}</code>. Para imágenes, define su posición, tamaño y añade un marco opcional.
            </li>
            <li>
              <strong>Genera:</strong> Haz clic en "Generar" para crear una credencial para cada fila de tus datos.
            </li>
          </ol>
          <p className="text-xs text-slate-400 mt-4 pt-4 border-t border-slate-700">
            <strong className="text-indigo-400">¡No te preocupes por perder tu trabajo!</strong> La configuración de tus campos (paso 4) y el patrón de nombre de archivo (paso 5) se guardan automáticamente en tu navegador para la próxima vez que visites.
          </p>
        </div>
      );
    };

    // --- From components/LivePreviewImage.tsx ---
    const LivePreviewImage = ({ field, currentPreviewRow, headers, photoFiles, scale }) => {
      const linkColumnLower = (field.linkColumn || '').toLowerCase();
      const colIndex = headers.findIndex(h => h.toLowerCase() === linkColumnLower);

      const photoBaseName = colIndex !== -1 && currentPreviewRow ? (currentPreviewRow[colIndex] || '').trim().toLowerCase() : null;
      const photoSrc = photoBaseName ? photoFiles[photoBaseName] : null;

      const frameStyle = {
        position: 'absolute',
        left: `${field.x * scale}px`,
        top: `${field.y * scale}px`,
        width: `${field.width * scale}px`,
        height: `${field.height * scale}px`,
        backgroundColor: field.frame?.color || 'transparent',
      };
      
      const thickness = field.frame?.thickness || 0;
      const innerX = thickness * scale;
      const innerY = thickness * scale;
      const innerWidth = (field.width - 2 * thickness) * scale;
      const innerHeight = (field.height - 2 * thickness) * scale;
      
      if (innerWidth <= 0 || innerHeight <= 0) {
        return <div style={frameStyle}></div>;
      }

      if (!photoSrc) {
         return (
            <div style={frameStyle}>
              <div style={{ position: 'absolute', left: innerX, top: innerY, width: innerWidth, height: innerHeight, backgroundColor: 'rgba(255, 255, 255, 0.1)', border: `1px dashed rgba(255, 255, 255, 0.3)`, display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: `${10 * scale}px`, color: 'rgba(255,255,255,0.5)', textAlign: 'center', overflow: 'hidden' }}>
                <span style={{padding: '2px'}}>Foto no encontrada para '{photoBaseName || 'N/A'}'</span>
              </div>
            </div>
         );
      }
      
      return (
        <div style={frameStyle}>
           <img src={photoSrc} alt={`Vista previa de ${photoBaseName}`} style={{ position: 'absolute', left: innerX, top: innerY, width: innerWidth, height: innerHeight, objectFit: 'cover' }} />
        </div>
      );
    };

    // --- From App.tsx ---
    const App = () => {
      const { useState, useCallback, useEffect, useRef, useMemo } = React;

      const loadInitialState = () => {
        try {
          const savedState = localStorage.getItem('credentialGeneratorConfig');
          if (savedState) {
            return JSON.parse(savedState);
          }
        } catch (error) {
          console.error("Error al cargar el estado desde localStorage:", error);
        }
        return {
          textFields: [
            { id: 1, content: '{{nombre}}\n{{apellidos}}', x: 150, y: 100, fontSize: 32, color: '#FFFFFF', isBold: true, isItalic: false },
            { id: 2, content: 'ID: {{id}} - {{puesto}}', x: 150, y: 180, fontSize: 20, color: '#DDDDDD', isBold: false, isItalic: false },
          ],
          imageFields: [
            { id: 1, x: 30, y: 80, width: 100, height: 100, linkColumn: 'id', frame: { color: '#ffffff', thickness: 4 } },
          ],
          filenamePattern: 'credencial-{{id}}.png',
        };
      };

      const [csvData, setCsvData] = useState('');
      const [excelFilename, setExcelFilename] = useState('');
      const [templateImage, setTemplateImage] = useState(null);
      const [imagePreview, setImagePreview] = useState(null);
      const [imageDimensions, setImageDimensions] = useState(null);
      const [textFields, setTextFields] = useState(loadInitialState().textFields);
      const [imageFields, setImageFields] = useState(loadInitialState().imageFields);
      const [photoFiles, setPhotoFiles] = useState({});
      const [photoUploadStatus, setPhotoUploadStatus] = useState('');
      const [filenamePattern, setFilenamePattern] = useState(loadInitialState().filenamePattern);
      const [generatedCredentials, setGeneratedCredentials] = useState([]);
      const [error, setError] = useState(null);
      const [isLoading, setIsLoading] = useState(false);
      const [showGrid, setShowGrid] = useState(false);
      const [mousePosition, setMousePosition] = useState(null);
      const [isZoomActive, setIsZoomActive] = useState(false);
      const [previewRowIndex, setPreviewRowIndex] = useState(0);
      const [validationErrors, setValidationErrors] = useState({});
      
      const imageRef = useRef(null);
      const previewImageRef = useRef(null);
      const restoreInputRef = useRef(null);

      useEffect(() => {
        try {
          const stateToSave = { textFields, imageFields, filenamePattern };
          localStorage.setItem('credentialGeneratorConfig', JSON.stringify(stateToSave));
        } catch (error) {
          console.error("Error al guardar el estado en localStorage:", error);
        }
      }, [textFields, imageFields, filenamePattern]);


      const parseCsv = (csv) => {
        const lines = csv.trim().split(/\r\n?|\n/).filter(line => line.trim() !== '');
        if (lines.length === 0) return { headers: [], rows: [] };
        const cleanCell = (cell) => {
            let value = cell.trim();
            if (value.startsWith('"') && value.endsWith('"')) {
                value = value.substring(1, value.length - 1);
            }
            return value.trim();
        };
        const headers = lines[0].replace(/^\uFEFF/, '').split(',').map(h => cleanCell(h).toLowerCase());
        const rows = lines.slice(1).map(line => line.split(',').map(cleanCell));
        return { headers, rows };
      };

      const replacePlaceholders = (template, headers, row) => {
        if (!row) return template;
        let result = template;
        headers.forEach((header, index) => {
          const escapedHeader = header.replace(/[-/\^$*+?.()|[\]{}]/g, '\\$&');
          const regex = new RegExp(`{{\\s*${escapedHeader}\\s*}}`, 'gi');
          result = result.replace(regex, row[index] || '');
        });
        return result;
      };

      const parsedCsv = useMemo(() => {
        try {
          if (!csvData.trim()) return { headers: [], rows: [] };
          const data = parseCsv(csvData);
          if (previewRowIndex >= data.rows.length) {
            setPreviewRowIndex(Math.max(0, data.rows.length - 1));
          }
          return data;
        } catch (e) {
          return { headers: [], rows: [] };
        }
      }, [csvData, previewRowIndex]);
      
      useEffect(() => {
        const errors = {};
        if (!templateImage) errors.templateImage = { message: "No se ha cargado una plantilla de imagen.", suggestion: "Sube un archivo JPG o PNG para usarlo como fondo." };
        const { headers, rows } = parsedCsv;
        if (!csvData.trim()) errors.csvData = { message: "No se han cargado datos.", suggestion: "Sube un archivo Excel (.xlsx, .xls) con los datos para las credenciales." };
        else {
          if (headers.length === 0) errors.csvData = { message: "El archivo no tiene una fila de encabezado válida.", suggestion: "Asegúrate de que la primera fila de tu hoja de Excel contenga los nombres de las columnas." };
          else {
            const inconsistentRows = rows.map((row, i) => ({ row, i })).filter(item => item.row.length !== headers.length);
            if (inconsistentRows.length > 0) errors.csvData = { message: `Las filas ${inconsistentRows.map(item => item.i + 2).join(', ')} tienen un número de columnas diferente.`, suggestion: "Revisa estas filas en tu archivo para asegurarte de que tengan el mismo número de columnas que el encabezado." };
            
            const getPlaceholders = (str) => (str.match(/{{\s*([^}\s]+)\s*}}/g) || []).map(p => p.replace(/{{\s*|\s*}}/g, ''));
            
            const checkPlaceholders = (text, keyPrefix) => {
              for (const placeholder of getPlaceholders(text)) {
                if (!headers.includes(placeholder.toLowerCase())) {
                  errors[keyPrefix] = { 
                    message: `El marcador '{{${placeholder}}}' no existe en los encabezados.`, 
                    suggestion: `Encabezados disponibles: ${headers.join(', ')}. Revisa que los nombres coincidan (no distingue mayúsculas/minúsculas).`
                  };
                }
              }
            };
            textFields.forEach(f => checkPlaceholders(f.content, `textField_${f.id}_content`));
            checkPlaceholders(filenamePattern, 'filenamePattern');
          }
        }
        if (imageFields.length > 0 && Object.keys(photoFiles).length === 0) errors.photoUpload = { message: "Hay campos de imagen definidos, pero no se han cargado fotos.", suggestion: "Selecciona los archivos de imagen correspondientes a los identificadores de tu archivo de datos." };
        if (imageFields.length > 0 && headers.length > 0) imageFields.forEach(field => {
          if (!field.linkColumn) errors[`imageField_${field.id}_linkColumn`] = { message: "No se ha vinculado una columna.", suggestion: "Selecciona la columna que contiene los identificadores de las fotos." };
          else if (!headers.includes(field.linkColumn.toLowerCase())) {
            errors[`imageField_${field.id}_linkColumn`] = { 
                message: `La columna '${field.linkColumn}' no existe en los encabezados.`, 
                suggestion: `Encabezados disponibles: ${headers.join(', ')}. Revisa que la columna seleccionada coincida con uno de ellos.`
            };
          }
        });
        setValidationErrors(errors);
      }, [csvData, templateImage, textFields, imageFields, photoFiles, filenamePattern, parsedCsv]);

      useEffect(() => {
        const handleKeyDown = (e) => { if (e.key === 'Alt') { e.preventDefault(); setIsZoomActive(true); }};
        const handleKeyUp = (e) => { if (e.key === 'Alt') setIsZoomActive(false); };
        const handleBlur = () => setIsZoomActive(false);
        window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp); window.addEventListener('blur', handleBlur);
        return () => { window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); window.removeEventListener('blur', handleBlur); };
      }, []);

      const handleImageChange = (e) => {
        const file = e.target.files?.[0];
        if (file) { 
          setTemplateImage(file); 
          const reader = new FileReader(); 
          reader.onloadend = () => setImagePreview(reader.result); 
          reader.readAsDataURL(file); 
        }
      };

      const handleExcelUpload = (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        setExcelFilename(file.name);
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const data = event.target?.result;
                const workbook = XLSX.read(data, { type: 'array' });
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const csv = XLSX.utils.sheet_to_csv(worksheet);
                setCsvData(csv);
                setError(null);
            } catch (err) {
                setError(`Error al procesar el archivo Excel: ${err.message}`);
                setCsvData('');
                setExcelFilename('');
            }
        };
        reader.onerror = () => {
            setError("No se pudo leer el archivo Excel.");
            setCsvData('');
            setExcelFilename('');
        };
        reader.readAsArrayBuffer(file);
      };

      const handlePhotoUpload = async (e) => {
        const files = e.target.files; if (!files || files.length === 0) return;
        setPhotoUploadStatus(`Cargando ${files.length} imágenes...`);
        try {
          const photoData = {};
          await Promise.all(Array.from(files).map((file) => new Promise((resolve, reject) => {
            if (!file.type.startsWith('image/')) return resolve();
            const key = (file.name.substring(0, file.name.lastIndexOf('.')) || file.name).trim().toLowerCase();
            if (key) { 
              const reader = new FileReader(); 
              reader.onloadend = () => { photoData[key] = reader.result; resolve(); }; 
              reader.onerror = reject; 
              reader.readAsDataURL(file); 
            } else resolve();
          })));
          setPhotoFiles(photoData); setPhotoUploadStatus(`${Object.keys(photoData).length} imágenes cargadas correctamente.`);
        } catch (err) { setPhotoUploadStatus('Error al leer los archivos de imagen.'); console.error(err); }
      };

      const handleMouseMoveOnImage = (e) => {
        if (!imageRef.current || !imageDimensions) return setMousePosition(null);
        const rect = imageRef.current.getBoundingClientRect();
        const offsetX = e.clientX - rect.left; const offsetY = e.clientY - rect.top;
        const scaleX = imageDimensions.width / imageRef.current.clientWidth; const scaleY = imageDimensions.height / imageRef.current.clientHeight;
        setMousePosition({ offsetX, offsetY, trueX: Math.round(offsetX * scaleX), trueY: Math.round(offsetY * scaleY) });
      };
      const handleMouseLeaveImage = () => setMousePosition(null);

      const handleAddField = () => setTextFields([...textFields, { id: Date.now(), content: 'Nuevo Campo', x: 50, y: 200, fontSize: 16, color: '#FFFFFF', isBold: false, isItalic: false }]);
      const handleAddImageField = () => setImageFields([...imageFields, { id: Date.now(), x: 50, y: 50, width: 100, height: 100, linkColumn: parsedCsv.headers[0] || '', frame: { color: '#FFFFFF', thickness: 0 } }]);
      const handleFieldChange = (id, field, value) => setTextFields(textFields.map(f => f.id === id ? { ...f, [field]: value } : f));
      const handleImageFieldChange = (id, field, value) => setImageFields(imageFields.map(f => f.id === id ? { ...f, [field]: value } : f));
      const handleRemoveField = (id) => setTextFields(textFields.filter(f => f.id !== id));
      const handleRemoveImageField = (id) => setImageFields(imageFields.filter(f => f.id !== id));

      const handleGenerate = useCallback(async () => {
        if (Object.keys(validationErrors).length > 0) { setError(`No se puede generar. Por favor, soluciona los problemas detectados.`); return; }
        setIsLoading(true); setError(null); setGeneratedCredentials([]);
        try {
          if (!imagePreview) throw new Error('La imagen de plantilla no está cargada.');
          const { headers, rows } = parsedCsv;
          const image = new Image(); image.src = imagePreview; await new Promise((res, rej) => { image.onload = res; image.onerror = rej; });
          const generatedImages = await Promise.all(rows.map(async (row) => {
            const canvas = document.createElement('canvas'); canvas.width = image.width; canvas.height = image.height; const ctx = canvas.getContext('2d'); if (!ctx) throw new Error('No se pudo obtener el contexto del canvas.');
            ctx.drawImage(image, 0, 0);
            for (const field of imageFields) {
              const linkColumnLower = (field.linkColumn || '').toLowerCase();
              const colIndex = headers.findIndex(h => h.toLowerCase() === linkColumnLower);
              if (colIndex === -1) continue;

              const photoBaseName = (row[colIndex] || '').trim().toLowerCase(); const photoSrc = photoFiles[photoBaseName];
              if (photoSrc) {
                const photoImg = new Image(); photoImg.src = photoSrc; await new Promise(res => { photoImg.onload = () => res(); });
                if (field.frame && field.frame.thickness > 0) {
                  ctx.fillStyle = field.frame.color || '#000000';
                  ctx.fillRect(field.x, field.y, field.width, field.height);
                }
                const thickness = field.frame?.thickness || 0;
                const destX = field.x + thickness; const destY = field.y + thickness; const destW = field.width - (2 * thickness); const destH = field.height - (2 * thickness);
                if (destW > 0 && destH > 0) {
                  const srcW = photoImg.naturalWidth; const srcH = photoImg.naturalHeight; const srcAR = srcW / srcH; const destAR = destW / destH;
                  let sWidth, sHeight, sx, sy;
                  if (srcAR > destAR) { sHeight = srcH; sWidth = srcH * destAR; sx = (srcW - sWidth) / 2; sy = 0; } 
                  else { sWidth = srcW; sHeight = srcW / destAR; sy = (srcH - sHeight) / 2; sx = 0; }
                  ctx.drawImage(photoImg, sx, sy, sWidth, sHeight, destX, destY, destW, destH);
                }
              }
            }
            ctx.textBaseline = 'top';
            textFields.forEach(field => {
              const fontStyle = field.isItalic ? 'italic' : 'normal'; const fontWeight = field.isBold ? 'bold' : 'normal'; const fontSize = parseInt(String(field.fontSize)) || 0;
              ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px sans-serif`; ctx.fillStyle = field.color;
              const text = replacePlaceholders(field.content, headers, row); const lines = text.split('\n'); const lineHeight = fontSize * 1.2;
              lines.forEach((line, index) => ctx.fillText(line, parseInt(String(field.x)) || 0, (parseInt(String(field.y)) || 0) + (index * lineHeight)));
            });
            const dataUrl = canvas.toDataURL('image/png'); const filename = replacePlaceholders(filenamePattern, headers, row) || `credencial-${rows.indexOf(row) + 1}.png`;
            return { dataUrl, filename };
          }));
          setGeneratedCredentials(generatedImages);
        } catch (e) { setError(e.message || 'Ocurrió un error desconocido durante la generación.'); } finally { setIsLoading(false); }
      }, [csvData, textFields, imageFields, photoFiles, imagePreview, filenamePattern, validationErrors, parsedCsv]);

      const handleDownloadAll = async () => {
        if (generatedCredentials.length === 0) return;
        const zip = new JSZip(); generatedCredentials.forEach(c => zip.file(c.filename, c.dataUrl.split(',')[1], { base64: true }));
        const blob = await zip.generateAsync({ type: 'blob' }); const url = URL.createObjectURL(blob); const link = document.createElement('a');
        link.href = url; link.download = 'credenciales-generadas.zip'; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
      };
      
      const handlePrevRow = () => setPreviewRowIndex(i => Math.max(0, i - 1));
      const handleNextRow = () => setPreviewRowIndex(i => Math.min(parsedCsv.rows.length - 1, i + 1));

      const handleSaveConfig = () => {
        try {
          const config = { textFields, imageFields, filenamePattern };
          const configJson = JSON.stringify(config, null, 2);
          const blob = new Blob([configJson], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'credencial_config.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (err) { setError("No se pudo guardar la configuración."); }
      };

      const handleRestoreConfig = (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const result = event.target?.result;
            if (typeof result === 'string') {
              const config = JSON.parse(result);
              if (config.textFields && Array.isArray(config.textFields) &&
                  config.imageFields && Array.isArray(config.imageFields) &&
                  typeof config.filenamePattern === 'string') {
                setTextFields(config.textFields);
                setImageFields(config.imageFields);
                setFilenamePattern(config.filenamePattern);
                setError(null);
              } else { throw new Error("El archivo de configuración tiene un formato inválido."); }
            }
          } catch (err) { setError(`Error al cargar configuración: ${err.message}`); }
        };
        reader.onerror = () => setError("No se pudo leer el archivo de configuración.");
        reader.readAsText(file);
        e.target.value = '';
      };
      
      const triggerRestore = () => {
        restoreInputRef.current?.click();
      };

      const magnifierSize = 128; const zoomLevel = 2;
      const previewScale = previewImageRef.current && imageDimensions ? previewImageRef.current.clientWidth / imageDimensions.width : 1;
      const currentPreviewRow = parsedCsv.rows[previewRowIndex];

      return (
        <div className="min-h-screen bg-slate-900 text-slate-200 font-sans p-4 sm:p-6 lg:p-8">
          <div className="max-w-7xl mx-auto">
            <Header />
            <Instructions />
            <div className="mt-8 grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
              <div className="flex flex-col gap-6">
                <div className="relative">
                  <label htmlFor="imageTemplate" className="block text-sm font-medium text-slate-400 mb-2">1. Carga tu Plantilla de Imagen</label>
                  <input id="imageTemplate" type="file" accept="image/png, image/jpeg" onChange={handleImageChange} className="w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-500" />
                  <ErrorBubble error={validationErrors.templateImage} />
                  {imagePreview && (
                     <div className="mt-4 relative inline-block cursor-crosshair" onMouseMove={handleMouseMoveOnImage} onMouseLeave={handleMouseLeaveImage}>
                        <img ref={imageRef} src={imagePreview} alt="Vista previa de la plantilla" className="rounded-md border border-slate-700 max-h-60 w-auto" onLoad={(e) => setImageDimensions({ width: e.currentTarget.naturalWidth, height: e.currentTarget.naturalHeight })} />
                        {showGrid && <div className="absolute top-0 left-0 w-full h-full pointer-events-none" style={{ backgroundImage: `linear-gradient(rgba(255,255,255,0.2) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.2) 1px, transparent 1px)`, backgroundSize: '50px 50px' }}></div>}
                        {mousePosition && showGrid && isZoomActive && <div className="absolute bg-slate-900/80 text-white text-xs rounded px-2 py-1 pointer-events-none z-20" style={{ top: `${mousePosition.offsetY - magnifierSize / 2 - 20}px`, left: `${mousePosition.offsetX}px`, transform: 'translate(-50%, -50%)' }}>X: {mousePosition.trueX}, Y: {mousePosition.trueY}</div>}
                        {imagePreview && showGrid && mousePosition && imageDimensions && isZoomActive && <div className="absolute rounded-full border-2 border-white shadow-lg pointer-events-none z-10" style={{ top: `${mousePosition.offsetY - magnifierSize / 2}px`, left: `${mousePosition.offsetX - magnifierSize / 2}px`, width: `${magnifierSize}px`, height: `${magnifierSize}px`, backgroundImage: `url(${imagePreview})`, backgroundSize: `${imageDimensions.width * zoomLevel}px ${imageDimensions.height * zoomLevel}px`, backgroundPosition: `-${mousePosition.trueX * zoomLevel - magnifierSize / 2}px -${mousePosition.trueY * zoomLevel - magnifierSize / 2}px`, backgroundRepeat: 'no-repeat' }} />}
                    </div>
                  )}
                   {imagePreview && <button onClick={() => setShowGrid(!showGrid)} className="mt-2 w-full text-sm text-slate-400 border border-slate-600 rounded-md py-2 hover:bg-slate-700/50 transition-colors flex items-center justify-center"><span>{showGrid ? "Ocultar Malla" : "Mostrar Malla"}</span>{showGrid && <span className="text-xs text-slate-500 ml-2 font-normal">(Mantén 'Alt' para Lupa)</span>}</button>}
                </div>

                <div className="relative">
                  <label htmlFor="excelUpload" className="block text-sm font-medium text-slate-400 mb-2">2. Sube tu Archivo de Datos</label>
                  <input id="excelUpload" type="file" accept=".xlsx, .xls, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel" onChange={handleExcelUpload} className="w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-500" />
                  {excelFilename && <p className="text-xs text-slate-400 mt-2">Archivo cargado: <span className="font-medium text-slate-300">{excelFilename}</span></p>}
                  <ErrorBubble error={validationErrors.csvData} />
                </div>
                
                <div className="relative">
                  <label htmlFor="photoUpload" className="block text-sm font-medium text-slate-400 mb-2">3. Carga las Fotos</label>
                  <input id="photoUpload" type="file" accept="image/png, image/jpeg, image/gif" multiple onChange={handlePhotoUpload} className="w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-500" />
                  <ErrorBubble error={validationErrors.photoUpload} />
                  {photoUploadStatus && <p className="text-xs text-slate-400 mt-2">{photoUploadStatus}</p>}
                </div>

                <div>
                  <h3 className="text-sm font-medium text-slate-400 mb-2">4. Define los Campos</h3>
                  <div className="flex gap-2 mb-4">
                     <button onClick={handleSaveConfig} className="flex-1 flex items-center justify-center gap-2 text-sm text-slate-300 bg-slate-700 hover:bg-slate-600 rounded-md py-2 transition-colors">
                         <Icon name="save" className="w-4 h-4" />
                         Guardar Configuración
                     </button>
                     <button onClick={triggerRestore} className="flex-1 flex items-center justify-center gap-2 text-sm text-slate-300 bg-slate-700 hover:bg-slate-600 rounded-md py-2 transition-colors">
                         <Icon name="upload" className="w-4 h-4" />
                         Restaurar Configuración
                     </button>
                  </div>
                  <input type="file" ref={restoreInputRef} onChange={handleRestoreConfig} accept=".json,application/json" style={{ display: 'none' }} />
                  
                  <div className="space-y-4">
                    <h4 className="text-xs font-bold uppercase text-slate-500 tracking-wider">Campos de Texto</h4>
                    {textFields.map((field) => (
                      <div key={field.id} className="grid grid-cols-12 gap-2 p-3 bg-slate-800 border border-slate-700 rounded-md">
                         <div className="col-span-12 relative"><label className="text-xs text-slate-500">Contenido</label><textarea value={field.content} onChange={e => handleFieldChange(field.id, 'content', e.target.value)} className="w-full bg-slate-700 border-slate-600 rounded p-1 text-sm font-mono" rows={2} /><ErrorBubble error={validationErrors[`textField_${field.id}_content`]} /></div>
                         <div className="col-span-2"><label className="text-xs text-slate-500">X</label><input type="number" value={field.x} onChange={e => handleFieldChange(field.id, 'x', parseInt(e.target.value) || 0)} className="w-full bg-slate-700 border-slate-600 rounded p-1 text-sm"/></div>
                         <div className="col-span-2"><label className="text-xs text-slate-500">Y</label><input type="number" value={field.y} onChange={e => handleFieldChange(field.id, 'y', parseInt(e.target.value) || 0)} className="w-full bg-slate-700 border-slate-600 rounded p-1 text-sm"/></div>
                         <div className="col-span-2"><label className="text-xs text-slate-500">Tamaño</label><input type="number" value={field.fontSize} onChange={e => handleFieldChange(field.id, 'fontSize', parseInt(e.target.value) || 0)} className="w-full bg-slate-700 border-slate-600 rounded p-1 text-sm"/></div>
                         <div className="col-span-2"><label className="text-xs text-slate-500">Color</label><input type="color" value={field.color} onChange={e => handleFieldChange(field.id, 'color', e.target.value)} className="w-full bg-slate-700 border-slate-600 rounded p-1 text-sm h-8"/></div>
                         <div className="col-span-4 flex items-end gap-2"><button onClick={() => handleFieldChange(field.id, 'isBold', !field.isBold)} className={`w-1/2 h-8 text-sm font-bold rounded ${field.isBold ? 'bg-indigo-500 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`} title="Negrita">N</button><button onClick={() => handleFieldChange(field.id, 'isItalic', !field.isItalic)} className={`w-1/2 h-8 text-sm italic font-serif rounded ${field.isItalic ? 'bg-indigo-500 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`} title="Cursiva">C</button></div>
                         <div className="col-span-12"><button onClick={() => handleRemoveField(field.id)} className="text-xs text-red-400 hover:text-red-300">Eliminar campo de texto</button></div>
                      </div>
                    ))}
                     <button onClick={handleAddField} className="w-full text-sm text-indigo-400 border border-indigo-500/50 rounded-md py-2 hover:bg-indigo-500/10 transition-colors">Añadir Campo de Texto</button>
                  </div>

                  <div className="space-y-4 mt-6">
                    <h4 className="text-xs font-bold uppercase text-slate-500 tracking-wider">Campos de Imagen</h4>
                     {imageFields.map((field) => (
                      <div key={field.id} className="grid grid-cols-12 gap-2 p-3 bg-slate-800 border border-slate-700 rounded-md">
                         <div className="col-span-12 relative">
                            <label className="text-xs text-slate-500">Columna de Vínculo (Nombre de Foto)</label>
                            <div className="relative">
                                <select value={field.linkColumn} onChange={e => handleImageFieldChange(field.id, 'linkColumn', e.target.value)} className="w-full bg-slate-700 border-slate-600 rounded p-1.5 text-sm appearance-none">
                                    <option value="" disabled>-- Selecciona Columna --</option>
                                    {parsedCsv.headers.map(header => (<option key={header} value={header}>{header.charAt(0).toUpperCase() + header.slice(1)}</option>))}
                                </select>
                                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-slate-400"><svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div>
                            </div>
                            <ErrorBubble error={validationErrors[`imageField_${field.id}_linkColumn`]} />
                         </div>
                         <div className="col-span-2"><label className="text-xs text-slate-500">X</label><input type="number" value={field.x} onChange={e => handleImageFieldChange(field.id, 'x', parseInt(e.target.value) || 0)} className="w-full bg-slate-700 border-slate-600 rounded p-1 text-sm"/></div>
                         <div className="col-span-2"><label className="text-xs text-slate-500">Y</label><input type="number" value={field.y} onChange={e => handleImageFieldChange(field.id, 'y', parseInt(e.target.value) || 0)} className="w-full bg-slate-700 border-slate-600 rounded p-1 text-sm"/></div>
                         <div className="col-span-2"><label className="text-xs text-slate-500">Ancho</label><input type="number" value={field.width} onChange={e => handleImageFieldChange(field.id, 'width', parseInt(e.target.value) || 0)} className="w-full bg-slate-700 border-slate-600 rounded p-1 text-sm"/></div>
                         <div className="col-span-2"><label className="text-xs text-slate-500">Alto</label><input type="number" value={field.height} onChange={e => handleImageFieldChange(field.id, 'height', parseInt(e.target.value) || 0)} className="w-full bg-slate-700 border-slate-600 rounded p-1 text-sm"/></div>
                         <div className="col-span-2"><label className="text-xs text-slate-500">Grosor Borde</label><input type="number" value={field.frame?.thickness || 0} onChange={e => handleImageFieldChange(field.id, 'frame', { ...field.frame, thickness: Math.max(0, parseInt(e.target.value) || 0) })} className="w-full bg-slate-700 border-slate-600 rounded p-1 text-sm"/></div>
                         <div className="col-span-2"><label className="text-xs text-slate-500">Color Borde</label><input type="color" value={field.frame?.color || '#FFFFFF'} onChange={e => handleImageFieldChange(field.id, 'frame', { ...field.frame, color: e.target.value })} className="w-full bg-slate-700 border-slate-600 rounded p-1 text-sm h-8"/></div>
                         <div className="col-span-12 mt-1"><button onClick={() => handleRemoveImageField(field.id)} className="text-xs text-red-400 hover:text-red-300">Eliminar campo de imagen</button></div>
                      </div>
                    ))}
                    <button onClick={handleAddImageField} className="w-full text-sm text-indigo-400 border border-indigo-500/50 rounded-md py-2 hover:bg-indigo-500/10 transition-colors">Añadir Campo de Imagen</button>
                  </div>
                </div>
                
                <div className="relative">
                    <label htmlFor="filenamePattern" className="block text-sm font-medium text-slate-400 mb-2">5. Define el Patrón de Nombre de Archivo</label>
                    <input id="filenamePattern" type="text" value={filenamePattern} onChange={(e) => setFilenamePattern(e.target.value)} className="w-full bg-slate-800 border border-slate-700 rounded-md p-3 text-sm font-mono focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-colors" placeholder="Ej: credencial-{{id}}.png" />
                    <ErrorBubble error={validationErrors.filenamePattern} />
                    <p className="text-xs text-slate-500 mt-1">Usa marcadores como `{'{{nombre}}'}`. No olvides la extensión (.png).</p>
                </div>

                <button onClick={handleGenerate} disabled={isLoading || Object.keys(validationErrors).length > 0} className="w-full flex items-center justify-center gap-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-indigo-800 disabled:text-slate-400 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-900 focus:ring-indigo-500">
                  {isLoading ? (<><Icon name="loading" />Generando...</>) : (<><Icon name="generate" />6. Generar Credenciales</>)}
                </button>
                {error && <p className="text-red-400 bg-red-900/50 p-3 rounded-md text-sm mt-4">{error}</p>}
              </div>

              <div className="lg:sticky lg:top-8 flex flex-col gap-8">
                <div>
                  <h3 className="text-sm font-medium text-slate-400 mb-2">Vista Previa en Vivo</h3>
                  <div className="bg-slate-800 border border-slate-700 rounded-md p-3">
                    {imagePreview && parsedCsv.rows.length > 0 ? (
                      <>
                        <div className="flex items-center justify-between mb-3">
                          <label className="text-xs text-slate-400">Fila de Datos:</label>
                          <div className="flex items-center gap-2">
                            <button onClick={handlePrevRow} disabled={previewRowIndex === 0} className="px-2 py-1 bg-slate-700 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-600 text-xs">Anterior</button>
                            <span className="text-sm font-mono bg-slate-900 px-2 py-1 rounded">{previewRowIndex + 1} / {parsedCsv.rows.length}</span>
                            <button onClick={handleNextRow} disabled={previewRowIndex >= parsedCsv.rows.length - 1} className="px-2 py-1 bg-slate-700 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-600 text-xs">Siguiente</button>
                          </div>
                        </div>
                        <div className="relative w-full overflow-hidden">
                          <img ref={previewImageRef} src={imagePreview} alt="Vista previa en vivo" className="w-full h-auto rounded-md" />
                          {imageFields.map(field => (
                            <LivePreviewImage
                              key={`preview-img-${field.id}`}
                              field={field}
                              currentPreviewRow={currentPreviewRow}
                              headers={parsedCsv.headers}
                              photoFiles={photoFiles}
                              scale={previewScale}
                            />
                          ))}
                          {textFields.map(field => (
                            <div key={`preview-${field.id}`} style={{ position: 'absolute', left: `${(field.x || 0) * previewScale}px`, top: `${(field.y || 0) * previewScale}px`, fontSize: `${(field.fontSize || 0) * previewScale}px`, color: field.color, fontFamily: 'sans-serif', fontWeight: field.isBold ? 'bold' : 'normal', fontStyle: field.isItalic ? 'italic' : 'normal', whiteSpace: 'pre-wrap', lineHeight: 1.2 }}>
                               {replacePlaceholders(field.content, parsedCsv.headers, currentPreviewRow)}
                            </div>
                          ))}
                        </div>
                      </>
                    ) : (
                      <div className="text-center text-slate-500 text-sm py-8">
                        {imagePreview ? "Sube un archivo de datos para ver la vista previa." : "Carga una imagen y datos para activar la vista previa."}
                      </div>
                    )}
                  </div>
                </div>
                
                <div className="bg-slate-800/50 border border-slate-700 rounded-lg p-4 flex flex-col">
                  <div className="flex justify-between items-center mb-4">
                    <h2 className="text-lg font-semibold text-slate-300">Resultados Generados</h2>
                    <button onClick={handleDownloadAll} disabled={generatedCredentials.length === 0} className="flex items-center gap-2 text-sm bg-slate-700 hover:bg-slate-600 disabled:bg-slate-800 disabled:text-slate-500 disabled:cursor-not-allowed text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                      <Icon name="download" />Descargar Todo (.zip)
                    </button>
                  </div>
                  <div className="flex-grow overflow-y-auto pr-2 space-y-4 h-96 lg:h-[calc(100vh-10rem-300px)]" style={{ scrollbarWidth: 'thin', scrollbarColor: '#475569 #1e293b' }}>
                    {generatedCredentials.length > 0 ? (
                      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        {generatedCredentials.map((cred, index) => (
                           <div key={index} className="relative group rounded-md overflow-hidden">
                              <img src={cred.dataUrl} alt={`Credencial generada ${cred.filename}`} className="w-full border-2 border-slate-700 block" />
                              <div className="absolute inset-0 bg-black/60 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                                <a href={cred.dataUrl} download={cred.filename} className="flex items-center gap-2 text-sm bg-indigo-600 hover:bg-indigo-500 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                  <Icon name="download" className="w-4 h-4" />Descargar PNG
                                </a>
                              </div>
                            </div>
                        ))}
                      </div>
                    ) : (
                      <div className="flex flex-col items-center justify-center h-full text-center text-slate-500">
                        <Icon name="placeholder" /><p className="mt-2">Tus credenciales generadas aparecerán aquí.</p>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // --- From index.tsx ---
    const rootElement = document.getElementById('root');
    const root = ReactDOM.createRoot(rootElement);
    root.render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );

  </script>
</body>
</html>
